####输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
思路：这也是道典型题，首先一定要明确什么样的二叉树可以称之为另一个二叉树的子二叉树，看结论：
也就是说，必须是完整的子树，从子树到叶子，无论是形状、值、个数必须完全一致
1、原二叉树走前序遍历，试图发现哪个节点的值和被判断子树的根节点相同；
如果一直到最后也没有找到那么肯定不是
2、如果找到了，就两个二叉树一起前序遍历，试图发现两个二叉树同时遍历完成，且同样的左右子树遍历过程中的节点值均相同，
同时遍历完成说明有相同的形状，左右子树遍历过程中的节点值均相同说明两个二叉树不仅形状一样，值也是一样，则可以认为是子树。
二叉树遍历：
先序遍历：（1）访问根节点；（2）采用先序递归遍历左子树；（3）采用先序递归遍历右子树；
中序遍历：（1）采用中序遍历左子树；（2）访问根节点；（3）采用中序遍历右子树
后序遍历：（1）采用后序递归遍历左子树；（2）采用后序递归遍历右子树；（3）访问根节点；
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        result = False
        if pRoot1 != None and pRoot2 != None:
            if pRoot1.val == pRoot2.val:
                result = self.DoesTree1haveTree2(pRoot1, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.left, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.right, pRoot2)
        return result
    # 用于递归判断树的每个节点是否相同
    # 需要注意的地方是: 前两个if语句不可以颠倒顺序
    # 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误
    def DoesTree1haveTree2(self, pRoot1, pRoot2):
        if pRoot2 == None:
            return True
        if pRoot1 == None:
            return False
        if pRoot1.val != pRoot2.val:
            return False
        return self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) and self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)
###解法
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
         
        def convert(p):
            if p:
                return str(p.val) +  convert(p.left) + convert(p.right)
            else:
                return ""
        return convert(pRoot2) in convert(pRoot1) if pRoot2 else False
